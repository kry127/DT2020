\import Algebra.Meta
\import Arith.Nat (pred)
\import Logic.Meta
\import Meta
\import Paths (inv)
\import hw11 ()
\import lect09 (Decide, no, yes)
\import lect11
\import Utils \hiding (<=-refl)

-- 1. Пусть f : A -> B и g : B -> C ─ некоторые функции.
--    Докажите, что если f и g инъективны, то g `o` f также инъективна.
--    Докажите, что если g `o` f инъективна, то f также инъективна.

-- Композиция функций
\func \fixr 9 o {A B C : \Type} (g : B -> C) (f : A -> B) => \lam a => g (f a)

\func o-inj {A B C : \Type} (f : A -> B) (g : B -> C) (p : isInj f) (q : isInj g) : isInj (g `o` f) =>
  (\lam a a' compeq => p a a' (\case f a \as b, f a' \as b', compeq : g b = g b' \return b = b' \with {
    b, b', cpeq => q b b' cpeq
  }))

\func o-inj' {A B C : \Type} (f : A -> B) (g : B -> C) (p : isInj (g `o` f)) : isInj f =>
  \lam a a' compeq => p a a' (pmap g compeq)

-- 2. Определите предикат "делится на 3 или на 5" так, чтобы он возвращал утверждения.
--    Докажите, что MultipleOf3Or5 вкладывается в ℕ.


\func isMultipleOf3Or5 (n : Nat) : \Type => \Sigma (mod3 n = 0 -> Empty) (mod5 n = 0 -> Empty) -> Empty

\func isMultipleOf3Or5-isProp (n : Nat) : isProp (isMultipleOf3Or5 n) => Impl-isProp (Empty-isProp)

\func MultipleOf3Or5 => \Sigma (n : Nat) (isMultipleOf3Or5 n)

\func Mul-inc (m : MultipleOf3Or5) => m.1

\func Mul-inc-isInj : isInj Mul-inc =>
  \lam a a' p => \let
                | x => isMultipleOf3Or5-isProp a'.1
    \in sigmaEq isMultipleOf3Or5 a a' p (x (transport isMultipleOf3Or5 p a.2) a'.2)

-- 3. Мы будем говорить, что тип A тривиален, если существует элемент в A, такой что любой другой элемент в A равен ему.
--    Докажите, что тип A тривиален тогда и только тогда, когда A является утверждением и A населен.

\func isTriv (A : \Type) => \Sigma (a : A) (\Pi (a' : A) -> a = a')

\func \infix 1 <-> (A B : \Type) => \Sigma (A -> B) (B -> A)

\func isTriv-lem (A : \Type) : isTriv A <-> (\Sigma (isProp A) A) => (isTriv-lem-> A, isTriv-lem<- A)
 \where {
   \func isTriv-lem<- (A : \Type) (hotel? : (\Sigma (isProp A) A)) : isTriv A
     => (hotel?.2, \lam x => hotel?.1 hotel?.2 x)

   \func isTriv-lem-> (A : \Type) (trivago : isTriv A) : (\Sigma (isProp A) A)
     => (\lam x y => (inv (trivago.2 x)) *> trivago.2 y, trivago.1)

 }

-- 4. Докажите, что Either не является утверждением в общем случаем.

\func Either-isProp (p : \Pi {A B : \Type} (pA : isProp A) (pB : isProp B) -> isProp (Either A B)) : Empty
  => \case p {\Sigma} {\Sigma} Unit-isProp Unit-isProp (Utils.inl ()) (Utils.inr ()) \with {}

-- 5. Докажите, что LessOrEq является предикатом.

\data LessOrEq (n m : Nat) : \Set0 \with
  | 0, m => z<=n
  | suc n, suc m => s<=s (LessOrEq n m)

\func LessOrEq-isProp {n m : Nat} : isProp (LessOrEq n m) => \lam x y => LessOrEq-isProp-recursive n m x y
  \where {
    \func LessOrEq-isProp-recursive (n m : Nat) (x y : LessOrEq n m) : x = y
      | 0, 0, z<=n, z<=n => idp
      | 0, suc m, z<=n, z<=n => idp
      | suc n, suc m, s<=s x, s<=s y => pmap (s<=s) (LessOrEq-isProp-recursive n m x y)
  }

-- 6. Докажте, что ReflClosure LessOrEq не является предикатом, а ReflClosure (\lam x y => T (x < y)) является.

\func \infix 4 < (n m : Nat) : Bool
  | _, 0 => false
  | 0, suc _ => true
  | suc n, suc m => n < m

\data ReflClosure (R : Nat -> Nat -> \Type) (x y : Nat)
  | refl (x = y)
  | inc (R x y)

\func Nat-isSet : isSet Nat
  => \lam x y => retract-isProp {x = y} Unit-isProp
      (\lam p => ()) (\lam t => {?}) (\lam p => \case \elim y, \elim p \with {
        | y, idp => idp
      })
\func ReflClosure_<-isProp (n m : Nat) : isProp (ReflClosure (\lam x y => T (x < y)) n m) => \lam x y => ReflClosure_<-isProp-refl n m x y
  \where {
    \func ReflClosure_<-isProp-refl (n m : Nat) (x y : ReflClosure (\lam x y => T (x < y)) n m) : x = y
      | 0, 0, _, inc ()
      | 0, 0, inc (), _
      | 0, suc _, refl (), _
      | 0, suc _, _, refl ()
      | 0, suc m, inc r, inc s => pmap inc (Unit-isProp r s)
      | suc _, 0, refl (), _
      | suc _, 0, inc (), _
      | n, m, refl x, refl y => pmap refl (equality-isProp Nat-isSet n m x y)
      | suc n, suc m, inc r, refl y =>  \case eq-pred-lemma y \as eq, n < m \as leq, idp : n < m = leq, r : T(leq) \with {
        | eq, true, p, n-leq-m-true => \let
          | n-leq-m-false => transport (\lam k => n < k = false) eq (<-refl-is-false n)
                                       \in contradiction
      }
      | suc n, suc m, refl x, inc s => \case eq-pred-lemma x \as eq, n < m \as leq, idp : n < m = leq, s : T(leq) \with {
        | eq, true, p, n-leq-m-true => \let
                               | n-leq-m-false => transport (\lam k => n < k = false) eq (<-refl-is-false n)
                            \in contradiction
      }
      | suc n, suc m, inc r, inc s => \let
        x =>  (\case n < m \as leq, r \as ru : T(leq), s \as su : T(leq) \return ru = su \with {
        | true, ru, su => Unit-isProp ru su
      }) \in pmap inc x

    \func eq-pred-lemma {m n : Nat} (p : suc m = suc n) : m = n \elim m, n, p
      | 0, 0, p => idp
      | suc m, suc n, p => pmap suc (eq-pred-lemma {m} {n} p)
    \func <-refl-is-false (n : Nat) : n < n = false
      | 0 => idp
      | suc n => <-refl-is-false n
  }


\func ReflClosure_<=-isNotProp (p : \Pi (n m : Nat) -> isProp (ReflClosure LessOrEq n m)) : Empty
  => \case p 0 0 (refl idp) (inc z<=n) \with {}

-- 7. Докажите, что если тип A вкладывается в тип B и B является утверждением, то и A является утверждением.

\func sub-isProp {A B : \Type} (f : A -> B) (p : isInj f) (q : isProp B) : isProp A =>
  \lam a b => p a b (q (f a) (f b))

-- 8. Докажите, что тип с разрешимым равенством являетя множеством.

\func Either-Unit-Empty-isProp : isProp (Either (\Sigma) (Empty))
  => \lam x y => \case \elim x, \elim y \with {
    | Either.inl a, Either.inl b => pmap Either.inl (Unit-isProp a b)
    | Either.inl a, Either.inr b => \case b \with {}
    | Either.inr b, Either.inl a => \case b \with {}
    | Either.inr a, Either.inr b => \case b \with {}
  }

\func Dec-isSet {A : \Type} (dec : \Pi (x y : A) -> Decide (x = y)) : isSet A
  =>  \lam x y => retract-isProp {x = y} Unit-isProp
      (\lam t => ()) (\lam t => \case dec x y \with {
        | yes a => a
        | no n => {?}
      }) (\lam p => \case \elim y, \elim p \with {
        | y, idp => idp
      })

-- 9. Если A и B являются множествами, то A `Or` B тоже является множеством.

\data \fixr 2 Or (A B : \Type)
  | inl A
  | inr B

\func or-isSet {A B : \Type} (p : isSet A) (q : isSet B) : isSet (Or A B) =>
  \lam x y => \case \elim x, \elim y \with {
    | inl a, inl b => retract-isProp {inl a = inl b} {a = b} (p a b) de-pmap-inl (pmap inl) pmap-depmap-inl-id
    | inl a, inr b => \lam u v => \case u \with {}
    | inr b, inl a => \lam u v => \case u \with {}
    | inr a, inr b => \lam u v => \let uu => (de-pmap-inr u) | vv => (de-pmap-inr v) \in q a b uu vv
  }
{-\func or-isSet {A B : \Type} (p : isSet A) (q : isSet B) : isSet (Or A B) =>
  \lam x y => \case \elim x, \elim y \with {
    | inl a, inl b => \lam u v => \let uu => (de-pmap-inl u) | vv => (de-pmap-inl v) \in retract-isProp {u = v}
    | inl a, inr b => \lam u v => \case u \with {}
    | inr b, inl a => \lam u v => \case u \with {}
    | inr a, inr b => \lam u v => \let uu => (de-pmap-inr u) | vv => (de-pmap-inr v) \in q a b uu vv
  }-}
  \where {
    \func de-inl {A B : \Type} (a : Or A B) (default : A) : A \elim a
      | inl a => a
      | inr b => default

    \func de-pmap-inl {A B : \Type} {a b : A} (p : inl {A} {B} a = inl {A} {B} b) : a = b
      => coe (\lam i => a = de-inl (p @ i) a) idp right
      -- почти то, что надо, но паттернматчиться на I нельзя
{-    => path (\lam i => \case i \as ii : I, p @ i \as pi, idp : p @ ii = pi  \with {
      | left, inl a, p1 => a
      | right, inl a, p1 => a
    })-}

    \func pmap-depmap-inl-id {A B : \Type} {a b : A} (p : inl {A} {B} a = inl {A} {B} b) : pmap (inl {A} {B}) (de-pmap-inl (p)) = p
      => {?}

    \func de-pmap-inr {A B : \Type} {a b : B} (p : inr {A} {B} a = inr {A} {B} b) : a = b
      => path (\lam i => \case p @ i \with {
        | inl _ => b
        | inr t => t
      })
  }

-- 10. Если B x является множеством, то \Pi (x : A) -> B x тоже является множеством.

\func pi-isSet {A : \Type} (B : A -> \Type) (p : \Pi (x : A) -> isSet (B x)) : isSet (\Pi (x : A) -> B x)
  => \lam x y => {?}

-- 11. Докажите, что если A является множеством, то List A также им является.

\func List-isSet {A : \Type} (pA : isSet A) : isSet (List A)
  => {?}

-- Optional:
-- 12. Докажите, что n-типы замкнуты относительно образования \Pi-типов.
--     Hint: Доказательство по индукции. Для случая suc n нужно доказать, что если f,g : \Pi (x : A) -> B x, то f = g эквивалентно \Pi (x : A) -> f x = g x.

\func levelPi {A : \Type} (B : A -> \Type) (n : Nat) (p : \Pi (x : A) -> B x `hasLevel` n) : (\Pi (x : A) -> B x) `hasLevel` n => {?}